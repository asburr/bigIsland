{
    "files": {
        "type": "composite",
        "desc": "outputs fully qualified file names of not (ever) previously processed files.",
        "eg": "{p: { p:<path> d:1 ro:<path> fs:[ { f:<fileo> re:*\\.csv } ] a:{ p:<path> dateSubDir:day purge:60 diskUsage:70 onError:<path> } } }",
        "root": {
            "type": "str", "key": true,
            "desc": "Root name for the feed of file names."
        }, "path": {
            "type": "composite",
            "desc": "path to be processed",
            "path": {
                 "type": "path", "default": ".",
                 "desc": "Path to load files from. Default is current directory."
            }, "depth": {
                "type": "int", "default": 0,
                "desc": "Specifies the depth of subdir searching under input dir. Values are: no subdir(0); unlimited depth(-1); or, a depth(N)"
            }, "readonly": {
                "type": "path", "default": null,
                "desc": "(ro) is used when path (p) is read only. Touch-files are created to track prior processed files. (ro) is a path on a writable file system where the touch-files can be created and deleted"
            }, "feeds": {
                "type": "listComposites",
                "feed": {
                    "type": "feed",
                    "desc": "Label the feed of file names. Use format to include root, {root}.name."
                },
                "regex": {
                    "type": "regex",
                    "desc": "Regex string. For a single feed use '.*' to match all files"
                }
            }
        },
        "archive": {
            "type": "composite", "default": null,
            "desc": "Archive processed files",
            "path": {
                "type": "path",
                "desc": "Successful loading of the file is moved to this location"
            }, "dateSubDir": {
                "type": "str", "default": "day",
                "choice": ["day", "month", "year", "none"],
                "desc": "Archive subdir by date of <path>/<dateSubDir>/[<fileSubDir>/]<file>"
            }, "purge": {
                "type": "int", "default": 432000,
                "desc": "Age of archive file in seconds after which archived file is deleted"
            }, "diskUsage": {
                "type": "int", "default": 70,
                "desc": "Percentage usage of the file system where the archive is located, at or above this usage triggers the oldest archived files to be deleted"
            }, "onError": {
                "type": "path", "default": null,
                "desc": "Failure to load whole or part of a file, this file is moved to this archive. Default is to delete the file that's in error when not readonly"
            }
        }
    },
    "loadf": {
        "type": "composite",
        "desc": "Loads data from a file",
        "eg": "{files: <feed> f:<feed> fstats:<feed> s:{ tshark: false csv: 1 file:{ f: <feed> oracleTable: <table> csvRowCount: 1 } }",
        "files": {
             "type": "feedRef",
             "desc": "Input feed containing the file-names that are loaded"
        }, "feed": {
             "type": "feed", "key": true,
             "desc": "Output feed containing the loaded data"
        }, "fstats": {
            "type": "feed",
            "desc": "Output Feed containing stats about the loaded data"
        }, "schema": {
            "type": "choice",
            "desc": "Define how to get the schema",
            "tshark": {
                "type": "bool", "default": true,
                "desc": "Process pcap files through tshark using -t json and use predefined procedures to clean up the tshark json."
            }, "csvHeaderRow": {
                "type": "int", "default": 0,
                "desc": "CSV row count for files containing a CSV header row at the row count. Rows prior to the header row, are ignored and not processed as data nor headers."
            }, "file": {
                "type": "composite",
                "desc": "Schema is found in a separate file",
                "feed": {
                     "type": "feedRef",
                     "desc": "Inputted file name(s) containing the schema"
                }, "filetype": {
                    "type": "choice",
                    "desc": "Type of schema in the file",
                    "oracleTable": {
                         "type": "str", "default": "",
                         "desc": "When not default, schema is an Oracle formatted schema, and look for the schema labeled with the table-name"
                    }, "csvRowCount": {
                         "type": "int", "default": 0,
                         "desc": "When gt 0, schema is csv formatted headers. This is the row count to the header row for this schema. Count starts at 1."
                    }
                }
            }
        }, "errors": {
            "type": "feed", "key": true,
            "default": "{feed}_errors",
            "desc": "Output feed containing filename and error, for files that failed to load."
        }, "cleanup": {
            "type": "composite", "default": null,
            "desc": "Instructions to cleanup the json that is outputted by parsing the data. These instructions are in addition to any automatic cleanup already performed by parsing",
            "valuelabels": {
                "type": "path", "default": null,
                "desc": "name of file with a list of <blocklabel>,<keylabel>,<replacelabel>."
            }, "ignore": {
                "type": "path", "default": null,
                "desc": "name of file with a list of <label> to ignore"
            }, "nest": {
                "type": "path", "default": null,
                "desc": "name of file with list of <label> to nest"
            }, "trunc": {
                "type": "path", "default": null,
                "desc": "name of file with list of <label>, <value> to be truncated beyond value"
            }
        }
    }, "logicalcondition.macro": {
        "type": "composite",
        "desc": "logical condition",
        "l": {
            "type": "field",
            "desc": "left handside of the condition is a field name"
        }, "o": {
            "type": "str", "default": "eq",
            "choice": ["eq", "ne", "gt", "lt", "gte", "lte"]
        }, "f": {
            "type": "field", "default": null,
            "desc": "right handside of the condition is a field name"
        }, "v": {
            "type": "any", "default": null,
            "desc": "right handside of the condition is a value"
        }
    }, "logicalexpression.macro": {
        "type": "composite",
        "desc": "A nested expression, i.e. (a eq 1 and b eq 2) or (a eq 3) is, { re:{ rc:{ l:a o:eq v:1 } o:and rc:{ l:b o:eq v:2 } } o:or c:{ l:a o:eq v:3 } }",
        "rc": {
            "type": "logicalcondition.macro", "default": null
        }, "re": {
            "type": "logicalexpression.macro", "default": null
        }, "o": {
            "type": "str", "default": "and",
            "choice": ["and", "or"]
        }, "c": {
            "type": "logicalcondition.macro"
        }
    }, "fieldwhere.macro": {
        "type": "composite",
        "desc": "Identification of fields and, can identify particular value. i.e. {f:fred, w:<expression>}",
        "f": {
            "type": "field"
        }, "w": {
            "type": "logicalexpression.macro", "default": "{}",
            "desc": "Default is the empty expression; all values."
        }
    }, "fieldpartition.macro": {
        "type": "composite",
        "desc": "Identification of fields and, may identify range of values. i.e. {f:fred, t:day}",
        "f": {
            "type": "field"
        }, "t": {
            "type": "str", "default": "day",
            "choice": ["month", "day", "hour"]
        }
    }, "loads": {
        "type": "composite",
        "desc": "Load a sum of field(s) identified explicitly by name or, the default is sum all number fields. Sum can be partitioned by field(s) from the same feed. { f:data i:datai fs:[ { f:<fieldwhere> } ] p:[ { f:<fieldPartition> w:<logicalExpression> } ] }",
        "feed": {
            "type": "feed", "key": true
        }, "input": {
            "type": "feedRef", "desc": "The other feed"
        }, "fields": {
            "type": "listComposites",
            "field": {
                "type": "fieldwhere.macro"
            }
        }, "partition": {
            "type": "listComposites",
            "field": {
                "type": "fieldpartition.macro"
            }
        }, "where": {
            "type": "logicalexpression.macro", "default": null,
            "desc": "restrict sum or, default is to sum all records"
        }
    }, "loadc": {
        "type": "composite",
        "desc": "Load a count of the occurence of field(s) identified explicitly by name or, the default is count all fields. Count can be partitioned by field(s) from the same feed. { f:data i:datai fs:[ { f:<fieldwhere> } ] p:[ { f:<fieldPartition> w:<logicalExpression> } ] }",
        "feed": {
            "type": "feed", "key": true
        }, "input": {
            "type": "feedRef", "desc": "The other feed"
        }, "fields": {
            "type": "listComposites",
            "field": {
                "type": "fieldwhere.macro"
            }
        }, "partition": {
            "type": "listComposites",
            "field": {
                "type": "fieldpartition.macro"
            },
            "where": {
                "type": "logicalexpression.macro", "default": null,
                "desc": "restrict count or, default is to count all records"
            }
        }
    }, "expand": {
        "type": "composite",
        "desc": "Add fields from values from within the same feed or from another feed. Two ways to join with the other feed. First is an explicit list of feed's fields. Second is by datatype, a list of datatypes identifies the feed's fields. { f:data j:{ fs:[ { f:<field> } ] } }",
        "feed": {
            "type": "feed", "key": true
        }, "input": {
            "type": "feedRef", "desc": "The feed to expand"
        }, "join": {
            "type": "composite", "default": null,
            "desc": "Join",
            "fields": {
                "type": "listComposites", "default": null,
                "desc": "List of feeds to join on.",
                "field": {
                    "type": "field"
                }
            }, "datatype": {
                "type": "str", "default": null,
                "desc": "Datatype with which to identify the field to join on. Alert when datatype is first obsolete in the feed. All fields with the datatype are expanded."
            }, "with": {
                "type": "feedRef", "default": null,
                "desc": "Name of the other feed to join with, default is to join with itself"
            }, "on": {
                "type": "listComposites", "default": null,
                "desc": "List of fields to join on. If datatype, then one field expected in o.f. Otherwise for named fields, then o.f must match the number of names in fs.f",
                "field": {
                    "type": "field"
                }
            }
        }, "add": {
            "type": "composite", "default": null,
            "add": {
                "type": "str",
                "desc": "{typefield}.name or fred.name. Where name is the new field"
            }, "fields": {
                "type": "listComposites", "default": null,
                "desc": "List of fields.",
                "field": {
                    "type": "field"
                }
            }, "fmt": {
                "type": "fmt",
                "desc": "{} style string format for new field. [] use python array slicing i.e. {}[1:3]. len({}) use python len to get the length of field."
            }
        }
    }, "alert": {
        "type": "composite",
        "desc": "{t:SUM e:fred@gmail.com p:60}",
        "feed": {
            "type": "feed", "default": "{input}_alert", "key": true,
            "desc": "Name for the feed of alerts"
        }, "input": {
            "type": "feedRef", "default": null,
            "desc": "Flow of events that trigger the alert or, default is all errors"
        }, "sumtype": {
            "type": "str", "default": "SUM", "choice": ["SUMPARTITIONED", "SUM"],
            "desc": "SUMPARTITIONED, one alert for each event; SUM, one alert for all events."
        }, "email": {
            "type": "email",
            "desc": "Email a breakdown of files failed to load"
        }, "period": {
            "type": "int", "default": 86400,
            "desc": "This is the period in second in between the email alerts."
        }
    }, "get": {
        "type": "composite",
        "desc": "Gets json objects from the dataset",
        "limit": {
            "type": "int", "default": 100,
            "desc": "Limit the number of retrieved objects"
        }
    }
}